<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>用于 gnet 的 Protocol buffers 编解码器 | johnpoint's blog</title><meta name=keywords content="gnet,tcp,Protocol buffers,codec,笔记"><meta name=description content="要写一个 TCP 服务端，实现处理在纯 TCP 流中传输的 Protocol buffers 数据。网络框架很早就选好了，用性能杰出的 gnet，问题是 gnet 的示例库里面没有直接解析纯 Protocol buffers 的编解码器，于是乎只能自己动手了&mldr;
协议分析 从 TCP 流里面传过来的是经过简单处理的 Protocol buffers 数据，他在数据的头携带了这个数据包的长度信息，像是这样
[ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ] 调用 golang 的 proto 官方库中的 func DecodeVarint(b []byte) (uint64, int) 方法可以从数据中拿到两个值，分别是 数据的完整长度、标明数据长度的头信息的长度。
由于没有特定的协议在包与包之间进行明显的划分，所以得用他的头数据来进行分包。
解码器 // 储存连接内的相关信息 type DataStruct struct { fullLength int lenNumLength int fullData []byte } func (d *Codec) Decode(c gnet."><meta name=author content="johnpoint"><link rel=canonical href=https://blog.lvcshu.com/2021/09/17/tcp-protocol-buffers-codec/><link crossorigin=anonymous href=/assets/css/stylesheet.18d56353e068ae97be459ab22536ebddc1be78cfab5ea7f8b0e5633d1c738a3f.css integrity="sha256-GNVjU+Borpe+RZqyJTbr3cG+eM+rXqf4sOVjPRxzij8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.lvcshu.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.lvcshu.com/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://blog.lvcshu.com/favicon.ico><link rel=apple-touch-icon href=https://blog.lvcshu.com/favicon.ico><link rel=mask-icon href=https://blog.lvcshu.com/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="用于 gnet 的 Protocol buffers 编解码器"><meta property="og:description" content="要写一个 TCP 服务端，实现处理在纯 TCP 流中传输的 Protocol buffers 数据。网络框架很早就选好了，用性能杰出的 gnet，问题是 gnet 的示例库里面没有直接解析纯 Protocol buffers 的编解码器，于是乎只能自己动手了&mldr;
协议分析 从 TCP 流里面传过来的是经过简单处理的 Protocol buffers 数据，他在数据的头携带了这个数据包的长度信息，像是这样
[ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ] 调用 golang 的 proto 官方库中的 func DecodeVarint(b []byte) (uint64, int) 方法可以从数据中拿到两个值，分别是 数据的完整长度、标明数据长度的头信息的长度。
由于没有特定的协议在包与包之间进行明显的划分，所以得用他的头数据来进行分包。
解码器 // 储存连接内的相关信息 type DataStruct struct { fullLength int lenNumLength int fullData []byte } func (d *Codec) Decode(c gnet."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.lvcshu.com/2021/09/17/tcp-protocol-buffers-codec/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-17T18:30:00+08:00"><meta property="article:modified_time" content="2021-09-17T18:30:00+08:00"><meta property="og:site_name" content="johnpoint's blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="用于 gnet 的 Protocol buffers 编解码器"><meta name=twitter:description content="要写一个 TCP 服务端，实现处理在纯 TCP 流中传输的 Protocol buffers 数据。网络框架很早就选好了，用性能杰出的 gnet，问题是 gnet 的示例库里面没有直接解析纯 Protocol buffers 的编解码器，于是乎只能自己动手了&mldr;
协议分析 从 TCP 流里面传过来的是经过简单处理的 Protocol buffers 数据，他在数据的头携带了这个数据包的长度信息，像是这样
[ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ] 调用 golang 的 proto 官方库中的 func DecodeVarint(b []byte) (uint64, int) 方法可以从数据中拿到两个值，分别是 数据的完整长度、标明数据长度的头信息的长度。
由于没有特定的协议在包与包之间进行明显的划分，所以得用他的头数据来进行分包。
解码器 // 储存连接内的相关信息 type DataStruct struct { fullLength int lenNumLength int fullData []byte } func (d *Codec) Decode(c gnet."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.lvcshu.com/posts/"},{"@type":"ListItem","position":2,"name":"用于 gnet 的 Protocol buffers 编解码器","item":"https://blog.lvcshu.com/2021/09/17/tcp-protocol-buffers-codec/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"用于 gnet 的 Protocol buffers 编解码器","name":"用于 gnet 的 Protocol buffers 编解码器","description":"要写一个 TCP 服务端，实现处理在纯 TCP 流中传输的 Protocol buffers 数据。网络框架很早就选好了，用性能杰出的 gnet，问题是 gnet 的示例库里面没有直接解析纯 Protocol buffers 的编解码器，于是乎只能自己动手了\u0026hellip;\n协议分析 从 TCP 流里面传过来的是经过简单处理的 Protocol buffers 数据，他在数据的头携带了这个数据包的长度信息，像是这样\n[ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ] 调用 golang 的 proto 官方库中的 func DecodeVarint(b []byte) (uint64, int) 方法可以从数据中拿到两个值，分别是 数据的完整长度、标明数据长度的头信息的长度。\n由于没有特定的协议在包与包之间进行明显的划分，所以得用他的头数据来进行分包。\n解码器 // 储存连接内的相关信息 type DataStruct struct { fullLength int lenNumLength int fullData []byte } func (d *Codec) Decode(c gnet.","keywords":["gnet","tcp","Protocol buffers","codec","笔记"],"articleBody":"要写一个 TCP 服务端，实现处理在纯 TCP 流中传输的 Protocol buffers 数据。网络框架很早就选好了，用性能杰出的 gnet，问题是 gnet 的示例库里面没有直接解析纯 Protocol buffers 的编解码器，于是乎只能自己动手了…\n协议分析 从 TCP 流里面传过来的是经过简单处理的 Protocol buffers 数据，他在数据的头携带了这个数据包的长度信息，像是这样\n[ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ] 调用 golang 的 proto 官方库中的 func DecodeVarint(b []byte) (uint64, int) 方法可以从数据中拿到两个值，分别是 数据的完整长度、标明数据长度的头信息的长度。\n由于没有特定的协议在包与包之间进行明显的划分，所以得用他的头数据来进行分包。\n解码器 // 储存连接内的相关信息 type DataStruct struct { fullLength int lenNumLength int fullData []byte } func (d *Codec) Decode(c gnet.Conn) ([]byte, error) { ctx, ok := c.Context().(context.Context) if !ok { err := c.Close() if err != nil { return nil, nil } } // 从上下文里面拿出这个连接的编解码器储存 struct r, ok := ctx.Value(\"codec\").(DataStruct) if !ok { err := c.Close() if err != nil { return nil, nil } } // 读取缓冲区内的所有信息 bytes := c.Read() // 判断是否已经开始读取包 if len(r.fullData) == 0 { // 调用函数获取头中带的信息 var fullLength uint64 fullLength, r.lenNumLength = proto.DecodeVarint(bytes) r.fullLength = int(fullLength) fmt.Println(r.fullLength, r.lenNumLength) if r.fullLength == 0 { return nil, nil } } // 拿到当前时间已经被储存进 struct 的数据的长度 fullDataLong := len(r.fullData) // 把读到的数据一把梭全部拼进 fullData r.fullData = append(r.fullData, bytes...) // 判断长度是否符合要求 if len(r.fullData) \u003e= r.fullLength+r.lenNumLength { c.ShiftN(r.fullLength + r.lenNumLength - fullDataLong) // 截取有效的数据 res := r.fullData[r.lenNumLength : r.fullLength+r.lenNumLength] // 连接的缓存清空 r.fullData = []byte{} ctx = context.WithValue(ctx, \"codec\", r) c.SetContext(ctx) return res, nil } // 移动读取指针 c.ShiftN(len(bytes)) ctx = context.WithValue(ctx, \"codec\", r) c.SetContext(ctx) return nil, nil } 上面那种解码方式是目前看运行状况来说暂时没有出现问题的方法，下面那一种则比较节省内存，两种解码方式区别主要是在于调用的 Read 函数不同，前者是把 gnet 的 ring buffer 里面的内容全部读取出来，而后者是先把头读取出来，拿到了完整的数据长度信息之后调用 ReadN 函数直接准确的将包体取出。\nfunc (d *Codec) Decode(c gnet.Conn) ([]byte, error) { ctx, ok := c.Context().(context.Context) if !ok { err := c.Close() if err != nil { return nil, nil } } // 从上下文里面拿出这个连接的编解码器储存 struct r, ok := ctx.Value(\"codec\").(DataStruct) if !ok { err := c.Close() if err != nil { return nil, nil } } if len(r.fullData) == 0 { _, bytes := c.ReadN(10) var fullLength uint64 fullLength, r.lenNumLength = proto.DecodeVarint(bytes) r.fullLength = int(fullLength) fmt.Println(r.fullLength, r.lenNumLength) if r.fullLength == 0 { return nil, nil } } fullDataLong := len(r.fullData) n, bytes := c.ReadN(r.fullLength + r.lenNumLength - fullDataLong) r.fullData = append(r.fullData, bytes...) c.ShiftN(n) if len(r.fullData) \u003e= r.fullLength+r.lenNumLength { res := r.fullData[r.lenNumLength :] r.fullData = []byte{} ctx = context.WithValue(ctx, \"codec\", r) c.SetContext(ctx) return res, nil } ctx = context.WithValue(ctx, \"codec\", r) c.SetContext(ctx) return nil, nil } 在代码中也可以看见，头数据中的包体长度信息我是存在连接的上下文中的，所以在 gnet 触发连接打开的事件时需要将储存信息的 struct 塞进上下文中。\nfunc (es *EventServer) OnOpened(c gnet.Conn) (out []byte, action gnet.Action) { ctx := context.WithValue(context.Background(), \"codec\", DataStruct{}) c.SetContext(ctx) return } 编码器 编码器这个部分就非常简单了，直接调用 proto 库里面的 EncodeVarint 函数就可以生成这个包体的头，将头信息放在包体的前面就可以将这个数据发送到客户端了。\nfunc (d *Codec) Encode(c gnet.Conn, buf []byte) ([]byte, error) { buf = append(proto.EncodeVarint(uint64(len(buf))), buf...) return buf, nil } 2021-11-09 更新 大意了，之前用上下文存储中间信息的方法有 严重的性能问题，在调用 golang 原生的 context.WithValue 方法时候，会在传入的上下文下面创建一个子上下文，这就导致了在一次又一次解码中，上下文树越来越庞大，而且每一层上下文内部都存储了本次解码的 DataStruct，造成内存泄漏的问题。\n在苦苦查了好几天，并且修了几个有可能的内存泄漏隐患之后我才意识到这一点(秃头.jpg)\n然后再看了下 gnet.Conn 的一个实现的 Context() 方法，发现他只是将我们传进去的东西存在了一个 map 里面，并不需要使用 context 相关的，所以简单的解决方法就是直接将 DataStruct 传进去，目前来看是解决了内存泄漏的问题，代码如下\nfunc (d *Codec) Decode(c gnet.Conn) ([]byte, error) { // 从上下文里面拿出这个连接的编解码器储存 struct r, ok := c.Context().(DataStruct) if !ok { err := c.Close() if err != nil { return nil, nil } } if len(r.fullData) == 0 { _, bytes := c.ReadN(10) var fullLength uint64 fullLength, r.lenNumLength = proto.DecodeVarint(bytes) r.fullLength = int(fullLength) fmt.Println(r.fullLength, r.lenNumLength) if r.fullLength == 0 { return nil, nil } } fullDataLong := len(r.fullData) n, bytes := c.ReadN(r.fullLength + r.lenNumLength - fullDataLong) r.fullData = append(r.fullData, bytes...) c.ShiftN(n) if len(r.fullData) \u003e= r.fullLength+r.lenNumLength { res := r.fullData[r.lenNumLength :] r.fullData = []byte{} c.SetContext(r) return res, nil } ctx = context.WithValue(ctx, \"codec\", r) c.SetContext(r) return nil, nil } func (es *EventServer) OnOpened(c gnet.Conn) (out []byte, action gnet.Action) { var r = DataStruct{} c.SetContext(r) return } 2021-12-24 更新 最近 gnet 发布了 v1.6.x 新版本，新版本的 编解码器行为有所改变，所以需要改造一下代码\n主要的改动是在 gnet 库的 eventloop_unix.go 文件的 d1ca7f3 commit 中将进入 React 的时间点从返回的 packet 不为 nil 改为了返回的 err 不为 nil，所以在升级后需要做对应的修改\nvar ( ContinueRead = errors.New(\"continue read\") ) func (d *Codec) Decode(c gnet.Conn) ([]byte, error) { // 从上下文里面拿出这个连接的编解码器储存 struct r, ok := c.Context().(DataStruct) if !ok { err := c.Close() if err != nil { return nil, nil } } if len(r.fullData) == 0 { _, bytes := c.ReadN(10) var fullLength uint64 fullLength, r.lenNumLength = proto.DecodeVarint(bytes) r.fullLength = int(fullLength) fmt.Println(r.fullLength, r.lenNumLength) if r.fullLength == 0 { return nil, ContinueRead } } fullDataLong := len(r.fullData) n, bytes := c.ReadN(r.fullLength + r.lenNumLength - fullDataLong) r.fullData = append(r.fullData, bytes...) c.ShiftN(n) if len(r.fullData) \u003e= r.fullLength+r.lenNumLength { res := r.fullData[r.lenNumLength :] r.fullData = []byte{} c.SetContext(r) return res, nil } ctx = context.WithValue(ctx, \"codec\", r) c.SetContext(r) return nil, ContinueRead } 参考资料 Go 语言设计与实现 \u003e 上下文 Context \u003e 传值方法 ","wordCount":"692","inLanguage":"en","datePublished":"2021-09-17T18:30:00+08:00","dateModified":"2021-09-17T18:30:00+08:00","author":{"@type":"Person","name":"johnpoint"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.lvcshu.com/2021/09/17/tcp-protocol-buffers-codec/"},"publisher":{"@type":"Organization","name":"johnpoint's blog","logo":{"@type":"ImageObject","url":"https://blog.lvcshu.com/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://blog.lvcshu.com/ accesskey=h title="johnpoint's blog (Alt + H)">johnpoint's blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://blog.lvcshu.com/posts/ title=归档><span>归档</span></a></li><li><a href=https://blog.lvcshu.com/friends/ title=友链><span>友链</span></a></li><li><a href=https://blog.lvcshu.com/about/ title=关于我><span>关于我</span></a></li><li><a href=https://blog.lvcshu.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>用于 gnet 的 Protocol buffers 编解码器</h1><div class=post-meta><span title='2021-09-17 18:30:00 +0800 CST'>2021-09-17 18:30:00</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;692 words&nbsp;·&nbsp;johnpoint</div></header><div class=post-content><p>要写一个 TCP 服务端，实现处理在纯 TCP 流中传输的 Protocol buffers 数据。网络框架很早就选好了，用性能杰出的 <a href=https://gnet.host/>gnet</a>，问题是 gnet 的示例库里面没有直接解析纯 Protocol buffers 的编解码器，于是乎只能自己动手了&mldr;</p><h2 id=协议分析>协议分析<a hidden class=anchor aria-hidden=true href=#协议分析>#</a></h2><p>从 TCP 流里面传过来的是经过简单处理的 Protocol buffers 数据，他在数据的头携带了这个数据包的长度信息，像是这样</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ]
</span></span></code></pre></div><p>调用 golang 的 proto 官方库中的 <code>func DecodeVarint(b []byte) (uint64, int)</code> 方法可以从数据中拿到两个值，分别是 数据的完整长度、标明数据长度的头信息的长度。</p><p>由于没有特定的协议在包与包之间进行明显的划分，所以得用他的头数据来进行分包。</p><h2 id=解码器>解码器<a hidden class=anchor aria-hidden=true href=#解码器>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 储存连接内的相关信息
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>DataStruct</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fullLength</span>   <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>lenNumLength</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>fullData</span>     <span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>Codec</span><span class=p>)</span> <span class=nf>Decode</span><span class=p>(</span><span class=nx>c</span> <span class=nx>gnet</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Context</span><span class=p>().(</span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 从上下文里面拿出这个连接的编解码器储存 struct
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>r</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Value</span><span class=p>(</span><span class=s>&#34;codec&#34;</span><span class=p>).(</span><span class=nx>DataStruct</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 读取缓冲区内的所有信息
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>bytes</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Read</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 判断是否已经开始读取包
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 调用函数获取头中带的信息
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=kd>var</span> <span class=nx>fullLength</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>		<span class=nx>fullLength</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>=</span> <span class=nx>proto</span><span class=p>.</span><span class=nf>DecodeVarint</span><span class=p>(</span><span class=nx>bytes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=p>=</span> <span class=nb>int</span><span class=p>(</span><span class=nx>fullLength</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 拿到当前时间已经被储存进 struct 的数据的长度
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fullDataLong</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 把读到的数据一把梭全部拼进 fullData
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>,</span> <span class=nx>bytes</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 判断长度是否符合要求
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span><span class=o>+</span><span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nf>ShiftN</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=o>+</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=o>-</span> <span class=nx>fullDataLong</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 截取有效的数据
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>res</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>[</span><span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>:</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span><span class=o>+</span><span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 连接的缓存清空
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>		<span class=nx>ctx</span> <span class=p>=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;codec&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nf>SetContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>res</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 移动读取指针
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>c</span><span class=p>.</span><span class=nf>ShiftN</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>bytes</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span> <span class=p>=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;codec&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>SetContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>上面那种解码方式是目前看运行状况来说暂时没有出现问题的方法，下面那一种则比较节省内存，两种解码方式区别主要是在于调用的 Read 函数不同，前者是把 gnet 的 ring buffer 里面的内容全部读取出来，而后者是先把头读取出来，拿到了完整的数据长度信息之后调用 ReadN 函数直接准确的将包体取出。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>Codec</span><span class=p>)</span> <span class=nf>Decode</span><span class=p>(</span><span class=nx>c</span> <span class=nx>gnet</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Context</span><span class=p>().(</span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 从上下文里面拿出这个连接的编解码器储存 struct
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>r</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Value</span><span class=p>(</span><span class=s>&#34;codec&#34;</span><span class=p>).(</span><span class=nx>DataStruct</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>_</span><span class=p>,</span> <span class=nx>bytes</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>ReadN</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=nx>fullLength</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>		<span class=nx>fullLength</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>=</span> <span class=nx>proto</span><span class=p>.</span><span class=nf>DecodeVarint</span><span class=p>(</span><span class=nx>bytes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=p>=</span> <span class=nb>int</span><span class=p>(</span><span class=nx>fullLength</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=nx>fullDataLong</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>n</span><span class=p>,</span> <span class=nx>bytes</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>ReadN</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=o>+</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=o>-</span> <span class=nx>fullDataLong</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>,</span> <span class=nx>bytes</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>ShiftN</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span><span class=o>+</span><span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>res</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>[</span><span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>:]</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>		<span class=nx>ctx</span> <span class=p>=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;codec&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nf>SetContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>res</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span> <span class=p>=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;codec&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>SetContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在代码中也可以看见，头数据中的包体长度信息我是存在连接的上下文中的，所以在 gnet 触发连接打开的事件时需要将储存信息的 struct 塞进上下文中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>es</span> <span class=o>*</span><span class=nx>EventServer</span><span class=p>)</span> <span class=nf>OnOpened</span><span class=p>(</span><span class=nx>c</span> <span class=nx>gnet</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>(</span><span class=nx>out</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>action</span> <span class=nx>gnet</span><span class=p>.</span><span class=nx>Action</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=s>&#34;codec&#34;</span><span class=p>,</span> <span class=nx>DataStruct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>SetContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=编码器>编码器<a hidden class=anchor aria-hidden=true href=#编码器>#</a></h2><p>编码器这个部分就非常简单了，直接调用 proto 库里面的 EncodeVarint 函数就可以生成这个包体的头，将头信息放在包体的前面就可以将这个数据发送到客户端了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>Codec</span><span class=p>)</span> <span class=nf>Encode</span><span class=p>(</span><span class=nx>c</span> <span class=nx>gnet</span><span class=p>.</span><span class=nx>Conn</span><span class=p>,</span> <span class=nx>buf</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>buf</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>proto</span><span class=p>.</span><span class=nf>EncodeVarint</span><span class=p>(</span><span class=nb>uint64</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>buf</span><span class=p>))),</span> <span class=nx>buf</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>buf</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=2021-11-09-更新>2021-11-09 更新<a hidden class=anchor aria-hidden=true href=#2021-11-09-更新>#</a></h2><p>大意了，之前用上下文存储中间信息的方法有 <strong>严重的性能问题</strong>，在调用 golang 原生的 <code>context.WithValue</code> 方法时候，会在传入的上下文下面创建一个子上下文，这就导致了在一次又一次解码中，上下文树越来越庞大，而且每一层上下文内部都存储了本次解码的 <code>DataStruct</code>，造成内存泄漏的问题。</p><p>在苦苦查了好几天，并且修了几个有可能的内存泄漏隐患之后我才意识到这一点(秃头.jpg)</p><p>然后再看了下 <code>gnet.Conn</code> 的一个实现的 <code>Context()</code> 方法，发现他只是将我们传进去的东西存在了一个 map 里面，并不需要使用 <code>context</code> 相关的，所以简单的解决方法就是直接将 <code>DataStruct</code> 传进去，目前来看是解决了内存泄漏的问题，代码如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>Codec</span><span class=p>)</span> <span class=nf>Decode</span><span class=p>(</span><span class=nx>c</span> <span class=nx>gnet</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 从上下文里面拿出这个连接的编解码器储存 struct
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>r</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Context</span><span class=p>().(</span><span class=nx>DataStruct</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>_</span><span class=p>,</span> <span class=nx>bytes</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>ReadN</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=nx>fullLength</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>		<span class=nx>fullLength</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>=</span> <span class=nx>proto</span><span class=p>.</span><span class=nf>DecodeVarint</span><span class=p>(</span><span class=nx>bytes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=p>=</span> <span class=nb>int</span><span class=p>(</span><span class=nx>fullLength</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=nx>fullDataLong</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>n</span><span class=p>,</span> <span class=nx>bytes</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>ReadN</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=o>+</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=o>-</span> <span class=nx>fullDataLong</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>,</span> <span class=nx>bytes</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>ShiftN</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span><span class=o>+</span><span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>res</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>[</span><span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>:]</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nf>SetContext</span><span class=p>(</span><span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>res</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span> <span class=p>=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;codec&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>SetContext</span><span class=p>(</span><span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>es</span> <span class=o>*</span><span class=nx>EventServer</span><span class=p>)</span> <span class=nf>OnOpened</span><span class=p>(</span><span class=nx>c</span> <span class=nx>gnet</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>(</span><span class=nx>out</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>action</span> <span class=nx>gnet</span><span class=p>.</span><span class=nx>Action</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>r</span> <span class=p>=</span> <span class=nx>DataStruct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>SetContext</span><span class=p>(</span><span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=2021-12-24-更新>2021-12-24 更新<a hidden class=anchor aria-hidden=true href=#2021-12-24-更新>#</a></h2><p>最近 gnet 发布了 v1.6.x 新版本，新版本的 编解码器行为有所改变，所以需要改造一下代码</p><p>主要的改动是在 gnet 库的 <a href=https://github.com/panjf2000/gnet/blob/d6cbe31e65ad3666acf8b4b9d4f55da9ec8c2fdd/eventloop_unix.go>eventloop_unix.go</a> 文件的 <a href=https://github.com/panjf2000/gnet/commit/302b2e55a1e0b62544983c0ea3d692fdaa5db4df#diff-b945f3b34ac34d1976944bc0c89304f8105c20362e3f915383250a3e0296f5c7R125>d1ca7f3</a> commit 中将进入 React 的时间点从返回的 packet 不为 nil 改为了返回的 err 不为 nil，所以在升级后需要做对应的修改</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=nx>ContinueRead</span> <span class=p>=</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;continue read&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>Codec</span><span class=p>)</span> <span class=nf>Decode</span><span class=p>(</span><span class=nx>c</span> <span class=nx>gnet</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 从上下文里面拿出这个连接的编解码器储存 struct
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>r</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Context</span><span class=p>().(</span><span class=nx>DataStruct</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>_</span><span class=p>,</span> <span class=nx>bytes</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>ReadN</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=nx>fullLength</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>		<span class=nx>fullLength</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>=</span> <span class=nx>proto</span><span class=p>.</span><span class=nf>DecodeVarint</span><span class=p>(</span><span class=nx>bytes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=p>=</span> <span class=nb>int</span><span class=p>(</span><span class=nx>fullLength</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>ContinueRead</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=nx>fullDataLong</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>n</span><span class=p>,</span> <span class=nx>bytes</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>ReadN</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=o>+</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=o>-</span> <span class=nx>fullDataLong</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>,</span> <span class=nx>bytes</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>ShiftN</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span><span class=o>+</span><span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>res</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>[</span><span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>:]</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nf>SetContext</span><span class=p>(</span><span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>res</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span> <span class=p>=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;codec&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>SetContext</span><span class=p>(</span><span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>ContinueRead</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2><ul><li><a href=https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/#614-%E4%BC%A0%E5%80%BC%E6%96%B9%E6%B3%95>Go 语言设计与实现 > 上下文 Context > 传值方法</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.lvcshu.com/tags/gnet/>gnet</a></li><li><a href=https://blog.lvcshu.com/tags/tcp/>tcp</a></li><li><a href=https://blog.lvcshu.com/tags/protocol-buffers/>Protocol buffers</a></li><li><a href=https://blog.lvcshu.com/tags/codec/>codec</a></li><li><a href=https://blog.lvcshu.com/tags/%E7%AC%94%E8%AE%B0/>笔记</a></li></ul><script>var pageInfo=`{"RawContent":"\\n要写一个 TCP 服务端，实现处理在纯 TCP 流中传输的 Protocol buffers 数据。网络框架很早就选好了，用性能杰出的 [gnet](https://gnet.host/)，问题是 gnet 的示例库里面没有直接解析纯 Protocol buffers 的编解码器，于是乎只能自己动手了...\\n\\n## 协议分析\\n\\n从 TCP 流里面传过来的是经过简单处理的 Protocol buffers 数据，他在数据的头携带了这个数据包的长度信息，像是这样\\n\\n\`\`\`\\n[ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ]\\n\`\`\`\\n\\n调用 golang 的 proto 官方库中的 \`func DecodeVarint(b []byte) (uint64, int)\` 方法可以从数据中拿到两个值，分别是 数据的完整长度、标明数据长度的头信息的长度。\\n\\n由于没有特定的协议在包与包之间进行明显的划分，所以得用他的头数据来进行分包。\\n\\n## 解码器\\n\\n\`\`\`go\\n// 储存连接内的相关信息\\ntype DataStruct struct {\\n\\tfullLength   int\\n\\tlenNumLength int\\n\\tfullData     []byte\\n}\\n\\nfunc (d *Codec) Decode(c gnet.Conn) ([]byte, error) {\\n\\tctx, ok := c.Context().(context.Context)\\n\\tif !ok {\\n\\t\\terr := c.Close()\\n\\t\\tif err != nil {\\n\\t\\t\\treturn nil, nil\\n\\t\\t}\\n\\t}\\n\\n    // 从上下文里面拿出这个连接的编解码器储存 struct\\n\\tr, ok := ctx.Value(\\"codec\\").(DataStruct)\\n\\tif !ok {\\n\\t\\terr := c.Close()\\n\\t\\tif err != nil {\\n\\t\\t\\treturn nil, nil\\n\\t\\t}\\n\\t}\\n\\n    // 读取缓冲区内的所有信息\\n\\tbytes := c.Read()\\n\\n    // 判断是否已经开始读取包\\n\\tif len(r.fullData) == 0 {\\n\\n        // 调用函数获取头中带的信息\\n\\t\\tvar fullLength uint64\\n\\t\\tfullLength, r.lenNumLength = proto.DecodeVarint(bytes)\\n\\t\\tr.fullLength = int(fullLength)\\n\\t\\tfmt.Println(r.fullLength, r.lenNumLength)\\n\\t\\tif r.fullLength == 0 {\\n\\t\\t\\treturn nil, nil\\n\\t\\t}\\n\\t}\\n\\n    // 拿到当前时间已经被储存进 struct 的数据的长度\\n\\tfullDataLong := len(r.fullData)\\n\\n    // 把读到的数据一把梭全部拼进 fullData\\n\\tr.fullData = append(r.fullData, bytes...)\\n\\n    // 判断长度是否符合要求\\n\\tif len(r.fullData) \\u003e= r.fullLength+r.lenNumLength {\\n\\t\\tc.ShiftN(r.fullLength + r.lenNumLength - fullDataLong)\\n\\n        // 截取有效的数据\\n\\t\\tres := r.fullData[r.lenNumLength : r.fullLength+r.lenNumLength]\\n\\n        // 连接的缓存清空\\n\\t\\tr.fullData = []byte{}\\n\\t\\tctx = context.WithValue(ctx, \\"codec\\", r)\\n\\t\\tc.SetContext(ctx)\\n\\t\\treturn res, nil\\n\\t}\\n\\n    // 移动读取指针\\n\\tc.ShiftN(len(bytes))\\n\\tctx = context.WithValue(ctx, \\"codec\\", r)\\n\\tc.SetContext(ctx)\\n\\treturn nil, nil\\n}\\n\`\`\`\\n\\n上面那种解码方式是目前看运行状况来说暂时没有出现问题的方法，下面那一种则比较节省内存，两种解码方式区别主要是在于调用的 Read 函数不同，前者是把 gnet 的 ring buffer 里面的内容全部读取出来，而后者是先把头读取出来，拿到了完整的数据长度信息之后调用 ReadN 函数直接准确的将包体取出。\\n\\n\`\`\`go\\nfunc (d *Codec) Decode(c gnet.Conn) ([]byte, error) {\\n\\tctx, ok := c.Context().(context.Context)\\n\\tif !ok {\\n\\t\\terr := c.Close()\\n\\t\\tif err != nil {\\n\\t\\t\\treturn nil, nil\\n\\t\\t}\\n\\t}\\n\\n    // 从上下文里面拿出这个连接的编解码器储存 struct\\n\\tr, ok := ctx.Value(\\"codec\\").(DataStruct)\\n\\tif !ok {\\n\\t\\terr := c.Close()\\n\\t\\tif err != nil {\\n\\t\\t\\treturn nil, nil\\n\\t\\t}\\n\\t}\\n    \\n\\tif len(r.fullData) == 0 {\\n\\t\\t_, bytes := c.ReadN(10)\\n\\t\\tvar fullLength uint64\\n\\t\\tfullLength, r.lenNumLength = proto.DecodeVarint(bytes)\\n\\t\\tr.fullLength = int(fullLength)\\n\\t\\tfmt.Println(r.fullLength, r.lenNumLength)\\n\\t\\tif r.fullLength == 0 {\\n\\t\\t\\treturn nil, nil\\n\\t\\t}\\n\\t}\\n    \\n\\tfullDataLong := len(r.fullData)\\n\\tn, bytes := c.ReadN(r.fullLength + r.lenNumLength - fullDataLong)\\n\\tr.fullData = append(r.fullData, bytes...)\\n\\tc.ShiftN(n)\\n\\tif len(r.fullData) \\u003e= r.fullLength+r.lenNumLength {\\n\\t\\tres := r.fullData[r.lenNumLength :]\\n\\t\\tr.fullData = []byte{}\\n\\t\\tctx = context.WithValue(ctx, \\"codec\\", r)\\n\\t\\tc.SetContext(ctx)\\n\\t\\treturn res, nil\\n\\t}\\n\\tctx = context.WithValue(ctx, \\"codec\\", r)\\n\\tc.SetContext(ctx)\\n\\treturn nil, nil\\n}\\n\`\`\`\\n\\n在代码中也可以看见，头数据中的包体长度信息我是存在连接的上下文中的，所以在 gnet 触发连接打开的事件时需要将储存信息的 struct 塞进上下文中。\\n\\n\`\`\`go\\nfunc (es *EventServer) OnOpened(c gnet.Conn) (out []byte, action gnet.Action) {\\n\\tctx := context.WithValue(context.Background(), \\"codec\\", DataStruct{})\\n\\tc.SetContext(ctx)\\n\\treturn\\n}\\n\`\`\`\\n\\n## 编码器\\n\\n编码器这个部分就非常简单了，直接调用 proto 库里面的 EncodeVarint 函数就可以生成这个包体的头，将头信息放在包体的前面就可以将这个数据发送到客户端了。\\n\\n\`\`\`go\\nfunc (d *Codec) Encode(c gnet.Conn, buf []byte) ([]byte, error) {\\n\\tbuf = append(proto.EncodeVarint(uint64(len(buf))), buf...)\\n\\treturn buf, nil\\n}\\n\`\`\`\\n\\n\\n## 2021-11-09 更新\\n\\n大意了，之前用上下文存储中间信息的方法有 **严重的性能问题**，在调用 golang 原生的 \`context.WithValue\` 方法时候，会在传入的上下文下面创建一个子上下文，这就导致了在一次又一次解码中，上下文树越来越庞大，而且每一层上下文内部都存储了本次解码的 \`DataStruct\`，造成内存泄漏的问题。\\n\\n在苦苦查了好几天，并且修了几个有可能的内存泄漏隐患之后我才意识到这一点(秃头.jpg)\\n\\n然后再看了下 \`gnet.Conn\` 的一个实现的 \`Context()\` 方法，发现他只是将我们传进去的东西存在了一个 map 里面，并不需要使用 \`context\` 相关的，所以简单的解决方法就是直接将 \`DataStruct\` 传进去，目前来看是解决了内存泄漏的问题，代码如下\\n\\n\`\`\`go\\nfunc (d *Codec) Decode(c gnet.Conn) ([]byte, error) {\\n\\t// 从上下文里面拿出这个连接的编解码器储存 struct\\n\\tr, ok := c.Context().(DataStruct)\\n\\tif !ok {\\n\\t\\terr := c.Close()\\n\\t\\tif err != nil {\\n\\t\\t\\treturn nil, nil\\n\\t\\t}\\n\\t}\\n    \\n\\tif len(r.fullData) == 0 {\\n\\t\\t_, bytes := c.ReadN(10)\\n\\t\\tvar fullLength uint64\\n\\t\\tfullLength, r.lenNumLength = proto.DecodeVarint(bytes)\\n\\t\\tr.fullLength = int(fullLength)\\n\\t\\tfmt.Println(r.fullLength, r.lenNumLength)\\n\\t\\tif r.fullLength == 0 {\\n\\t\\t\\treturn nil, nil\\n\\t\\t}\\n\\t}\\n    \\n\\tfullDataLong := len(r.fullData)\\n\\tn, bytes := c.ReadN(r.fullLength + r.lenNumLength - fullDataLong)\\n\\tr.fullData = append(r.fullData, bytes...)\\n\\tc.ShiftN(n)\\n\\tif len(r.fullData) \\u003e= r.fullLength+r.lenNumLength {\\n\\t\\tres := r.fullData[r.lenNumLength :]\\n\\t\\tr.fullData = []byte{}\\n\\t\\tc.SetContext(r)\\n\\t\\treturn res, nil\\n\\t}\\n\\tctx = context.WithValue(ctx, \\"codec\\", r)\\n\\tc.SetContext(r)\\n\\treturn nil, nil\\n}\\n\`\`\`\\n\\n\`\`\`go\\nfunc (es *EventServer) OnOpened(c gnet.Conn) (out []byte, action gnet.Action) {\\n\\tvar r = DataStruct{}\\n\\tc.SetContext(r)\\n\\treturn\\n}\\n\`\`\`\\n\\n\\n## 2021-12-24 更新\\n\\n最近 gnet 发布了 v1.6.x 新版本，新版本的 编解码器行为有所改变，所以需要改造一下代码\\n\\n主要的改动是在 gnet 库的 [eventloop_unix.go](https://github.com/panjf2000/gnet/blob/d6cbe31e65ad3666acf8b4b9d4f55da9ec8c2fdd/eventloop_unix.go) 文件的 [d1ca7f3](https://github.com/panjf2000/gnet/commit/302b2e55a1e0b62544983c0ea3d692fdaa5db4df#diff-b945f3b34ac34d1976944bc0c89304f8105c20362e3f915383250a3e0296f5c7R125) commit 中将进入 React 的时间点从返回的 packet 不为 nil 改为了返回的 err 不为 nil，所以在升级后需要做对应的修改\\n\\n\\n\`\`\`go\\nvar (\\n\\tContinueRead = errors.New(\\"continue read\\")\\n)\\n\\n\\nfunc (d *Codec) Decode(c gnet.Conn) ([]byte, error) {\\n\\t// 从上下文里面拿出这个连接的编解码器储存 struct\\n\\tr, ok := c.Context().(DataStruct)\\n\\tif !ok {\\n\\t\\terr := c.Close()\\n\\t\\tif err != nil {\\n\\t\\t\\treturn nil, nil\\n\\t\\t}\\n\\t}\\n    \\n\\tif len(r.fullData) == 0 {\\n\\t\\t_, bytes := c.ReadN(10)\\n\\t\\tvar fullLength uint64\\n\\t\\tfullLength, r.lenNumLength = proto.DecodeVarint(bytes)\\n\\t\\tr.fullLength = int(fullLength)\\n\\t\\tfmt.Println(r.fullLength, r.lenNumLength)\\n\\t\\tif r.fullLength == 0 {\\n\\t\\t\\treturn nil, ContinueRead\\n\\t\\t}\\n\\t}\\n    \\n\\tfullDataLong := len(r.fullData)\\n\\tn, bytes := c.ReadN(r.fullLength + r.lenNumLength - fullDataLong)\\n\\tr.fullData = append(r.fullData, bytes...)\\n\\tc.ShiftN(n)\\n\\tif len(r.fullData) \\u003e= r.fullLength+r.lenNumLength {\\n\\t\\tres := r.fullData[r.lenNumLength :]\\n\\t\\tr.fullData = []byte{}\\n\\t\\tc.SetContext(r)\\n\\t\\treturn res, nil\\n\\t}\\n\\tctx = context.WithValue(ctx, \\"codec\\", r)\\n\\tc.SetContext(r)\\n\\treturn nil, ContinueRead\\n}\\n\`\`\`\\n\\n## 参考资料\\n\\n- [Go 语言设计与实现 \\u003e 上下文 Context \\u003e 传值方法](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/#614-%E4%BC%A0%E5%80%BC%E6%96%B9%E6%B3%95)","ResourceType":"page","MediaType":{"mainType":"application","subType":"octet-stream","delimiter":".","type":"application/octet-stream","string":"application/octet-stream","suffixes":[""]},"Permalink":"https://blog.lvcshu.com/2021/09/17/tcp-protocol-buffers-codec/","RelPermalink":"/2021/09/17/tcp-protocol-buffers-codec/","Name":"用于 gnet 的 Protocol buffers 编解码器","Title":"用于 gnet 的 Protocol buffers 编解码器","Params":{"date":"2021-09-17T18:30:00+08:00","draft":false,"iscjklanguage":false,"lastmod":"2021-09-17T18:30:00+08:00","publishdate":"2021-09-17T18:30:00+08:00","slug":"tcp-protocol-buffers-codec","tags":["gnet","tcp","Protocol buffers","codec","笔记"],"title":"用于 gnet 的 Protocol buffers 编解码器","toc":true},"Data":{},"Date":"2021-09-17T18:30:00+08:00","Lastmod":"2021-09-17T18:30:00+08:00","PublishDate":"2021-09-17T18:30:00+08:00","ExpiryDate":"0001-01-01T00:00:00Z","Aliases":null,"BundleType":"","Description":"","Draft":false,"IsHome":false,"Keywords":null,"Kind":"page","Layout":"","LinkTitle":"用于 gnet 的 Protocol buffers 编解码器","IsNode":false,"IsPage":true,"Path":"posts/tcp-protocol-buffers-codec.md","Pathc":"posts/tcp-protocol-buffers-codec.md","Slug":"tcp-protocol-buffers-codec","Lang":"en","IsSection":false,"Section":"posts","SectionsEntries":["posts"],"SectionsPath":"posts","Sitemap":{"ChangeFreq":"","Priority":-1,"Filename":"sitemap.xml"},"Type":"posts","Weight":0,"Language":{"Lang":"en","LanguageName":"","LanguageCode":"","Title":"","LanguageDirection":"","Weight":0,"Disabled":false},"File":{"File":{}},"GitInfo":{"hash":"","abbreviatedHash":"","subject":"","authorName":"","authorEmail":"","authorDate":"0001-01-01T00:00:00Z","commitDate":"0001-01-01T00:00:00Z"},"CodeOwners":null,"OutputFormats":[{"Rel":"canonical","Format":{"mediaType":"text/html","name":"html","path":"","baseName":"index","rel":"canonical","protocol":"","isPlainText":false,"isHTML":true,"noUgly":false,"notAlternative":false,"permalinkable":true,"weight":10}}],"AlternativeOutputFormats":null,"Menus":null,"TranslationKey":"page/posts/tcp-protocol-buffers-codec","IsTranslated":false,"AllTranslations":null,"Translations":null,"Store":{},"GetIdentity":{"Type":"content","Path":"posts/tcp-protocol-buffers-codec.md"}}`</script><div><ul class=post-copyright><li class=post-copyright-author><a>本文作者: </a>johnpoint</li><li class=post-copyright-link><a>本文链接:</a>
<a href id=copyrightlink>https://blog.lvcshu.com/2021/09/17/tcp-protocol-buffers-codec/</a></li><li class=post-copyright-license><a>版权声明:</a>
本作品采用<a rel=license href=http://creativecommons.org/licenses/by-sa/4.0/>知识共享署名-相同方式共享 4.0 国际许可协议</a>进行许可。</li><svg xmlns="http://www.w3.org/2000/svg" class="copyright-img" viewBox="0 0 496 512"><path fill="#4a4a4a" d="m245.8 214.9-33.2 17.3c-9.4-19.6-25.2-20-27.4-20-22.2.0-33.3 14.6-33.3 43.9.0 23.5 9.2 43.8 33.3 43.8 14.4.0 24.6-7 30.5-21.3l30.6 15.5a73.2 73.2.0 01-65.1 39c-22.6.0-74-10.3-74-77 0-58.7 43-77 72.6-77 30.8-.1 52.7 11.9 66 35.8zm143 0-32.7 17.3c-9.5-19.8-25.7-20-27.9-20-22.1.0-33.2 14.6-33.2 43.9.0 23.5 9.2 43.8 33.2 43.8 14.5.0 24.7-7 30.5-21.3l31 15.5c-2 3.8-21.3 39-65 39-22.7.0-74-9.9-74-77 0-58.7 43-77 72.6-77C354 179 376 191 389 214.8zM247.7 8C104.7 8 0 123 0 256c0 138.4 113.6 248 247.6 248C377.5 504 496 403 496 256 496 118 389.4 8 247.6 8zm.8 450.8c-112.5.0-203.7-93-203.7-202.8.0-105.5 85.5-203.3 203.8-203.3A201.7 201.7.0 01451.3 256c0 121.7-99.7 202.9-202.9 202.9z"/></svg></ul></div><nav class=paginav><a class=prev href=https://blog.lvcshu.com/2021/11/24/zerotier-%E6%9E%84%E5%BB%BA%E5%86%85%E7%BD%91/><span class=title>« Prev</span><br><span>使用 Zerotier 异地组内网</span></a>
<a class=next href=https://blog.lvcshu.com/2021/07/28/%E8%A7%A3%E5%86%B3%E5%85%A8%E5%B1%8F%E8%83%8C%E6%99%AF%E5%9B%BE%E5%8D%A1%E9%A1%BF/><span class=title>Next »</span><br><span>解决全屏背景图卡顿</span></a></nav><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://johnpoints-blog-hexo.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></footer></article><style>.copyright-img{position:absolute;width:128px;height:128px;top:-35px;right:5%;opacity:.1;filter:invert(100%)}.post-copyright{border-radius:var(--radius);margin:2em 0 0;padding:.5em 1em;border-left:3px solid #ff1700;background-color:var(--code-bg);list-style:none;position:relative;overflow:hidden}.post-copyright li{margin:8px 0}</style></main><footer class=footer><span>&copy; 2023 <a href=https://blog.lvcshu.com/>johnpoint's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script async defer data-website-id=7319ce07-a672-4d99-bf07-9ebb227d449d src=https://umami.uipo.cc/umami.js></script></body></html>