<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>用于 gnet 的 Protocol buffers 编解码器 | johnpoint's blog</title>
<meta name=keywords content="gnet,tcp,Protocol buffers,codec,笔记"><meta name=description content='要写一个 TCP 服务端，实现处理在纯 TCP 流中传输的 Protocol buffers 数据。网络框架很早就选好了，用性能杰出的 gnet，问题是 gnet 的示例库里面没有直接解析纯 Protocol buffers 的编解码器，于是乎只能自己动手了&mldr;
协议分析
从 TCP 流里面传过来的是经过简单处理的 Protocol buffers 数据，他在数据的头携带了这个数据包的长度信息，像是这样
[ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ]
调用 golang 的 proto 官方库中的 func DecodeVarint(b []byte) (uint64, int) 方法可以从数据中拿到两个值，分别是 数据的完整长度、标明数据长度的头信息的长度。
由于没有特定的协议在包与包之间进行明显的划分，所以得用他的头数据来进行分包。
解码器
// 储存连接内的相关信息
type DataStruct struct {
	fullLength   int
	lenNumLength int
	fullData     []byte
}

func (d *Codec) Decode(c gnet.Conn) ([]byte, error) {
	ctx, ok := c.Context().(context.Context)
	if !ok {
		err := c.Close()
		if err != nil {
			return nil, nil
		}
	}

    // 从上下文里面拿出这个连接的编解码器储存 struct
	r, ok := ctx.Value("codec").(DataStruct)
	if !ok {
		err := c.Close()
		if err != nil {
			return nil, nil
		}
	}

    // 读取缓冲区内的所有信息
	bytes := c.Read()

    // 判断是否已经开始读取包
	if len(r.fullData) == 0 {

        // 调用函数获取头中带的信息
		var fullLength uint64
		fullLength, r.lenNumLength = proto.DecodeVarint(bytes)
		r.fullLength = int(fullLength)
		fmt.Println(r.fullLength, r.lenNumLength)
		if r.fullLength == 0 {
			return nil, nil
		}
	}

    // 拿到当前时间已经被储存进 struct 的数据的长度
	fullDataLong := len(r.fullData)

    // 把读到的数据一把梭全部拼进 fullData
	r.fullData = append(r.fullData, bytes...)

    // 判断长度是否符合要求
	if len(r.fullData) >= r.fullLength+r.lenNumLength {
		c.ShiftN(r.fullLength + r.lenNumLength - fullDataLong)

        // 截取有效的数据
		res := r.fullData[r.lenNumLength : r.fullLength+r.lenNumLength]

        // 连接的缓存清空
		r.fullData = []byte{}
		ctx = context.WithValue(ctx, "codec", r)
		c.SetContext(ctx)
		return res, nil
	}

    // 移动读取指针
	c.ShiftN(len(bytes))
	ctx = context.WithValue(ctx, "codec", r)
	c.SetContext(ctx)
	return nil, nil
}
上面那种解码方式是目前看运行状况来说暂时没有出现问题的方法，下面那一种则比较节省内存，两种解码方式区别主要是在于调用的 Read 函数不同，前者是把 gnet 的 ring buffer 里面的内容全部读取出来，而后者是先把头读取出来，拿到了完整的数据长度信息之后调用 ReadN 函数直接准确的将包体取出。'><meta name=author content="johnpoint"><link rel=canonical href=https://blog.lvcshu.com/2021/09/17/tcp-protocol-buffers-codec/><link crossorigin=anonymous href=/assets/css/stylesheet.9a07b9c81cbc95fa741d61ca6489dcdb8491591c19dca31d14a124a4ba95ec80.css integrity="sha256-mge5yBy8lfp0HWHKZInc24SRWRwZ3KMdFKEkpLqV7IA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://blog.lvcshu.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.lvcshu.com/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://blog.lvcshu.com/favicon.ico><link rel=apple-touch-icon href=https://blog.lvcshu.com/favicon.ico><link rel=mask-icon href=https://blog.lvcshu.com/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.lvcshu.com/2021/09/17/tcp-protocol-buffers-codec/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="用于 gnet 的 Protocol buffers 编解码器"><meta property="og:description" content='要写一个 TCP 服务端，实现处理在纯 TCP 流中传输的 Protocol buffers 数据。网络框架很早就选好了，用性能杰出的 gnet，问题是 gnet 的示例库里面没有直接解析纯 Protocol buffers 的编解码器，于是乎只能自己动手了&mldr;
协议分析
从 TCP 流里面传过来的是经过简单处理的 Protocol buffers 数据，他在数据的头携带了这个数据包的长度信息，像是这样
[ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ]
调用 golang 的 proto 官方库中的 func DecodeVarint(b []byte) (uint64, int) 方法可以从数据中拿到两个值，分别是 数据的完整长度、标明数据长度的头信息的长度。
由于没有特定的协议在包与包之间进行明显的划分，所以得用他的头数据来进行分包。
解码器
// 储存连接内的相关信息
type DataStruct struct {
	fullLength   int
	lenNumLength int
	fullData     []byte
}

func (d *Codec) Decode(c gnet.Conn) ([]byte, error) {
	ctx, ok := c.Context().(context.Context)
	if !ok {
		err := c.Close()
		if err != nil {
			return nil, nil
		}
	}

    // 从上下文里面拿出这个连接的编解码器储存 struct
	r, ok := ctx.Value("codec").(DataStruct)
	if !ok {
		err := c.Close()
		if err != nil {
			return nil, nil
		}
	}

    // 读取缓冲区内的所有信息
	bytes := c.Read()

    // 判断是否已经开始读取包
	if len(r.fullData) == 0 {

        // 调用函数获取头中带的信息
		var fullLength uint64
		fullLength, r.lenNumLength = proto.DecodeVarint(bytes)
		r.fullLength = int(fullLength)
		fmt.Println(r.fullLength, r.lenNumLength)
		if r.fullLength == 0 {
			return nil, nil
		}
	}

    // 拿到当前时间已经被储存进 struct 的数据的长度
	fullDataLong := len(r.fullData)

    // 把读到的数据一把梭全部拼进 fullData
	r.fullData = append(r.fullData, bytes...)

    // 判断长度是否符合要求
	if len(r.fullData) >= r.fullLength+r.lenNumLength {
		c.ShiftN(r.fullLength + r.lenNumLength - fullDataLong)

        // 截取有效的数据
		res := r.fullData[r.lenNumLength : r.fullLength+r.lenNumLength]

        // 连接的缓存清空
		r.fullData = []byte{}
		ctx = context.WithValue(ctx, "codec", r)
		c.SetContext(ctx)
		return res, nil
	}

    // 移动读取指针
	c.ShiftN(len(bytes))
	ctx = context.WithValue(ctx, "codec", r)
	c.SetContext(ctx)
	return nil, nil
}
上面那种解码方式是目前看运行状况来说暂时没有出现问题的方法，下面那一种则比较节省内存，两种解码方式区别主要是在于调用的 Read 函数不同，前者是把 gnet 的 ring buffer 里面的内容全部读取出来，而后者是先把头读取出来，拿到了完整的数据长度信息之后调用 ReadN 函数直接准确的将包体取出。'><meta property="og:type" content="article"><meta property="og:url" content="https://blog.lvcshu.com/2021/09/17/tcp-protocol-buffers-codec/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-17T18:30:00+08:00"><meta property="article:modified_time" content="2021-09-17T18:30:00+08:00"><meta property="og:site_name" content="johnpoint's blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="用于 gnet 的 Protocol buffers 编解码器"><meta name=twitter:description content='要写一个 TCP 服务端，实现处理在纯 TCP 流中传输的 Protocol buffers 数据。网络框架很早就选好了，用性能杰出的 gnet，问题是 gnet 的示例库里面没有直接解析纯 Protocol buffers 的编解码器，于是乎只能自己动手了&mldr;
协议分析
从 TCP 流里面传过来的是经过简单处理的 Protocol buffers 数据，他在数据的头携带了这个数据包的长度信息，像是这样
[ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ]
调用 golang 的 proto 官方库中的 func DecodeVarint(b []byte) (uint64, int) 方法可以从数据中拿到两个值，分别是 数据的完整长度、标明数据长度的头信息的长度。
由于没有特定的协议在包与包之间进行明显的划分，所以得用他的头数据来进行分包。
解码器
// 储存连接内的相关信息
type DataStruct struct {
	fullLength   int
	lenNumLength int
	fullData     []byte
}

func (d *Codec) Decode(c gnet.Conn) ([]byte, error) {
	ctx, ok := c.Context().(context.Context)
	if !ok {
		err := c.Close()
		if err != nil {
			return nil, nil
		}
	}

    // 从上下文里面拿出这个连接的编解码器储存 struct
	r, ok := ctx.Value("codec").(DataStruct)
	if !ok {
		err := c.Close()
		if err != nil {
			return nil, nil
		}
	}

    // 读取缓冲区内的所有信息
	bytes := c.Read()

    // 判断是否已经开始读取包
	if len(r.fullData) == 0 {

        // 调用函数获取头中带的信息
		var fullLength uint64
		fullLength, r.lenNumLength = proto.DecodeVarint(bytes)
		r.fullLength = int(fullLength)
		fmt.Println(r.fullLength, r.lenNumLength)
		if r.fullLength == 0 {
			return nil, nil
		}
	}

    // 拿到当前时间已经被储存进 struct 的数据的长度
	fullDataLong := len(r.fullData)

    // 把读到的数据一把梭全部拼进 fullData
	r.fullData = append(r.fullData, bytes...)

    // 判断长度是否符合要求
	if len(r.fullData) >= r.fullLength+r.lenNumLength {
		c.ShiftN(r.fullLength + r.lenNumLength - fullDataLong)

        // 截取有效的数据
		res := r.fullData[r.lenNumLength : r.fullLength+r.lenNumLength]

        // 连接的缓存清空
		r.fullData = []byte{}
		ctx = context.WithValue(ctx, "codec", r)
		c.SetContext(ctx)
		return res, nil
	}

    // 移动读取指针
	c.ShiftN(len(bytes))
	ctx = context.WithValue(ctx, "codec", r)
	c.SetContext(ctx)
	return nil, nil
}
上面那种解码方式是目前看运行状况来说暂时没有出现问题的方法，下面那一种则比较节省内存，两种解码方式区别主要是在于调用的 Read 函数不同，前者是把 gnet 的 ring buffer 里面的内容全部读取出来，而后者是先把头读取出来，拿到了完整的数据长度信息之后调用 ReadN 函数直接准确的将包体取出。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.lvcshu.com/posts/"},{"@type":"ListItem","position":2,"name":"用于 gnet 的 Protocol buffers 编解码器","item":"https://blog.lvcshu.com/2021/09/17/tcp-protocol-buffers-codec/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"用于 gnet 的 Protocol buffers 编解码器","name":"用于 gnet 的 Protocol buffers 编解码器","description":"要写一个 TCP 服务端，实现处理在纯 TCP 流中传输的 Protocol buffers 数据。网络框架很早就选好了，用性能杰出的 gnet，问题是 gnet 的示例库里面没有直接解析纯 Protocol buffers 的编解码器，于是乎只能自己动手了\u0026hellip;\n协议分析 从 TCP 流里面传过来的是经过简单处理的 Protocol buffers 数据，他在数据的头携带了这个数据包的长度信息，像是这样\n[ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ] 调用 golang 的 proto 官方库中的 func DecodeVarint(b []byte) (uint64, int) 方法可以从数据中拿到两个值，分别是 数据的完整长度、标明数据长度的头信息的长度。\n由于没有特定的协议在包与包之间进行明显的划分，所以得用他的头数据来进行分包。\n解码器 // 储存连接内的相关信息 type DataStruct struct { fullLength int lenNumLength int fullData []byte } func (d *Codec) Decode(c gnet.Conn) ([]byte, error) { ctx, ok := c.Context().(context.Context) if !ok { err := c.Close() if err != nil { return nil, nil } } // 从上下文里面拿出这个连接的编解码器储存 struct r, ok := ctx.Value(\u0026#34;codec\u0026#34;).(DataStruct) if !ok { err := c.Close() if err != nil { return nil, nil } } // 读取缓冲区内的所有信息 bytes := c.Read() // 判断是否已经开始读取包 if len(r.fullData) == 0 { // 调用函数获取头中带的信息 var fullLength uint64 fullLength, r.lenNumLength = proto.DecodeVarint(bytes) r.fullLength = int(fullLength) fmt.Println(r.fullLength, r.lenNumLength) if r.fullLength == 0 { return nil, nil } } // 拿到当前时间已经被储存进 struct 的数据的长度 fullDataLong := len(r.fullData) // 把读到的数据一把梭全部拼进 fullData r.fullData = append(r.fullData, bytes...) // 判断长度是否符合要求 if len(r.fullData) \u0026gt;= r.fullLength+r.lenNumLength { c.ShiftN(r.fullLength + r.lenNumLength - fullDataLong) // 截取有效的数据 res := r.fullData[r.lenNumLength : r.fullLength+r.lenNumLength] // 连接的缓存清空 r.fullData = []byte{} ctx = context.WithValue(ctx, \u0026#34;codec\u0026#34;, r) c.SetContext(ctx) return res, nil } // 移动读取指针 c.ShiftN(len(bytes)) ctx = context.WithValue(ctx, \u0026#34;codec\u0026#34;, r) c.SetContext(ctx) return nil, nil } 上面那种解码方式是目前看运行状况来说暂时没有出现问题的方法，下面那一种则比较节省内存，两种解码方式区别主要是在于调用的 Read 函数不同，前者是把 gnet 的 ring buffer 里面的内容全部读取出来，而后者是先把头读取出来，拿到了完整的数据长度信息之后调用 ReadN 函数直接准确的将包体取出。\n","keywords":["gnet","tcp","Protocol buffers","codec","笔记"],"articleBody":"要写一个 TCP 服务端，实现处理在纯 TCP 流中传输的 Protocol buffers 数据。网络框架很早就选好了，用性能杰出的 gnet，问题是 gnet 的示例库里面没有直接解析纯 Protocol buffers 的编解码器，于是乎只能自己动手了…\n协议分析 从 TCP 流里面传过来的是经过简单处理的 Protocol buffers 数据，他在数据的头携带了这个数据包的长度信息，像是这样\n[ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ] 调用 golang 的 proto 官方库中的 func DecodeVarint(b []byte) (uint64, int) 方法可以从数据中拿到两个值，分别是 数据的完整长度、标明数据长度的头信息的长度。\n由于没有特定的协议在包与包之间进行明显的划分，所以得用他的头数据来进行分包。\n解码器 // 储存连接内的相关信息 type DataStruct struct { fullLength int lenNumLength int fullData []byte } func (d *Codec) Decode(c gnet.Conn) ([]byte, error) { ctx, ok := c.Context().(context.Context) if !ok { err := c.Close() if err != nil { return nil, nil } } // 从上下文里面拿出这个连接的编解码器储存 struct r, ok := ctx.Value(\"codec\").(DataStruct) if !ok { err := c.Close() if err != nil { return nil, nil } } // 读取缓冲区内的所有信息 bytes := c.Read() // 判断是否已经开始读取包 if len(r.fullData) == 0 { // 调用函数获取头中带的信息 var fullLength uint64 fullLength, r.lenNumLength = proto.DecodeVarint(bytes) r.fullLength = int(fullLength) fmt.Println(r.fullLength, r.lenNumLength) if r.fullLength == 0 { return nil, nil } } // 拿到当前时间已经被储存进 struct 的数据的长度 fullDataLong := len(r.fullData) // 把读到的数据一把梭全部拼进 fullData r.fullData = append(r.fullData, bytes...) // 判断长度是否符合要求 if len(r.fullData) \u003e= r.fullLength+r.lenNumLength { c.ShiftN(r.fullLength + r.lenNumLength - fullDataLong) // 截取有效的数据 res := r.fullData[r.lenNumLength : r.fullLength+r.lenNumLength] // 连接的缓存清空 r.fullData = []byte{} ctx = context.WithValue(ctx, \"codec\", r) c.SetContext(ctx) return res, nil } // 移动读取指针 c.ShiftN(len(bytes)) ctx = context.WithValue(ctx, \"codec\", r) c.SetContext(ctx) return nil, nil } 上面那种解码方式是目前看运行状况来说暂时没有出现问题的方法，下面那一种则比较节省内存，两种解码方式区别主要是在于调用的 Read 函数不同，前者是把 gnet 的 ring buffer 里面的内容全部读取出来，而后者是先把头读取出来，拿到了完整的数据长度信息之后调用 ReadN 函数直接准确的将包体取出。\nfunc (d *Codec) Decode(c gnet.Conn) ([]byte, error) { ctx, ok := c.Context().(context.Context) if !ok { err := c.Close() if err != nil { return nil, nil } } // 从上下文里面拿出这个连接的编解码器储存 struct r, ok := ctx.Value(\"codec\").(DataStruct) if !ok { err := c.Close() if err != nil { return nil, nil } } if len(r.fullData) == 0 { _, bytes := c.ReadN(10) var fullLength uint64 fullLength, r.lenNumLength = proto.DecodeVarint(bytes) r.fullLength = int(fullLength) fmt.Println(r.fullLength, r.lenNumLength) if r.fullLength == 0 { return nil, nil } } fullDataLong := len(r.fullData) n, bytes := c.ReadN(r.fullLength + r.lenNumLength - fullDataLong) r.fullData = append(r.fullData, bytes...) c.ShiftN(n) if len(r.fullData) \u003e= r.fullLength+r.lenNumLength { res := r.fullData[r.lenNumLength :] r.fullData = []byte{} ctx = context.WithValue(ctx, \"codec\", r) c.SetContext(ctx) return res, nil } ctx = context.WithValue(ctx, \"codec\", r) c.SetContext(ctx) return nil, nil } 在代码中也可以看见，头数据中的包体长度信息我是存在连接的上下文中的，所以在 gnet 触发连接打开的事件时需要将储存信息的 struct 塞进上下文中。\nfunc (es *EventServer) OnOpened(c gnet.Conn) (out []byte, action gnet.Action) { ctx := context.WithValue(context.Background(), \"codec\", DataStruct{}) c.SetContext(ctx) return } 编码器 编码器这个部分就非常简单了，直接调用 proto 库里面的 EncodeVarint 函数就可以生成这个包体的头，将头信息放在包体的前面就可以将这个数据发送到客户端了。\nfunc (d *Codec) Encode(c gnet.Conn, buf []byte) ([]byte, error) { buf = append(proto.EncodeVarint(uint64(len(buf))), buf...) return buf, nil } 2021-11-09 更新 大意了，之前用上下文存储中间信息的方法有 严重的性能问题，在调用 golang 原生的 context.WithValue 方法时候，会在传入的上下文下面创建一个子上下文，这就导致了在一次又一次解码中，上下文树越来越庞大，而且每一层上下文内部都存储了本次解码的 DataStruct，造成内存泄漏的问题。\n在苦苦查了好几天，并且修了几个有可能的内存泄漏隐患之后我才意识到这一点(秃头.jpg)\n然后再看了下 gnet.Conn 的一个实现的 Context() 方法，发现他只是将我们传进去的东西存在了一个 map 里面，并不需要使用 context 相关的，所以简单的解决方法就是直接将 DataStruct 传进去，目前来看是解决了内存泄漏的问题，代码如下\nfunc (d *Codec) Decode(c gnet.Conn) ([]byte, error) { // 从上下文里面拿出这个连接的编解码器储存 struct r, ok := c.Context().(DataStruct) if !ok { err := c.Close() if err != nil { return nil, nil } } if len(r.fullData) == 0 { _, bytes := c.ReadN(10) var fullLength uint64 fullLength, r.lenNumLength = proto.DecodeVarint(bytes) r.fullLength = int(fullLength) fmt.Println(r.fullLength, r.lenNumLength) if r.fullLength == 0 { return nil, nil } } fullDataLong := len(r.fullData) n, bytes := c.ReadN(r.fullLength + r.lenNumLength - fullDataLong) r.fullData = append(r.fullData, bytes...) c.ShiftN(n) if len(r.fullData) \u003e= r.fullLength+r.lenNumLength { res := r.fullData[r.lenNumLength :] r.fullData = []byte{} c.SetContext(r) return res, nil } ctx = context.WithValue(ctx, \"codec\", r) c.SetContext(r) return nil, nil } func (es *EventServer) OnOpened(c gnet.Conn) (out []byte, action gnet.Action) { var r = DataStruct{} c.SetContext(r) return } 2021-12-24 更新 最近 gnet 发布了 v1.6.x 新版本，新版本的 编解码器行为有所改变，所以需要改造一下代码\n主要的改动是在 gnet 库的 eventloop_unix.go 文件的 d1ca7f3 commit 中将进入 React 的时间点从返回的 packet 不为 nil 改为了返回的 err 不为 nil，所以在升级后需要做对应的修改\nvar ( ContinueRead = errors.New(\"continue read\") ) func (d *Codec) Decode(c gnet.Conn) ([]byte, error) { // 从上下文里面拿出这个连接的编解码器储存 struct r, ok := c.Context().(DataStruct) if !ok { err := c.Close() if err != nil { return nil, nil } } if len(r.fullData) == 0 { _, bytes := c.ReadN(10) var fullLength uint64 fullLength, r.lenNumLength = proto.DecodeVarint(bytes) r.fullLength = int(fullLength) fmt.Println(r.fullLength, r.lenNumLength) if r.fullLength == 0 { return nil, ContinueRead } } fullDataLong := len(r.fullData) n, bytes := c.ReadN(r.fullLength + r.lenNumLength - fullDataLong) r.fullData = append(r.fullData, bytes...) c.ShiftN(n) if len(r.fullData) \u003e= r.fullLength+r.lenNumLength { res := r.fullData[r.lenNumLength :] r.fullData = []byte{} c.SetContext(r) return res, nil } ctx = context.WithValue(ctx, \"codec\", r) c.SetContext(r) return nil, ContinueRead } 参考资料 Go 语言设计与实现 \u003e 上下文 Context \u003e 传值方法 ","wordCount":"692","inLanguage":"en","datePublished":"2021-09-17T18:30:00+08:00","dateModified":"2021-09-17T18:30:00+08:00","author":{"@type":"Person","name":"johnpoint"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.lvcshu.com/2021/09/17/tcp-protocol-buffers-codec/"},"publisher":{"@type":"Organization","name":"johnpoint's blog","logo":{"@type":"ImageObject","url":"https://blog.lvcshu.com/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.lvcshu.com/ accesskey=h title="johnpoint's blog (Alt + H)">johnpoint's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li></li></ul></div></div><ul id=menu><li><a href=https://blog.lvcshu.com/posts/ title=归档><span>归档</span></a></li><li><a href=https://blog.lvcshu.com/friends/ title=友链><span>友链</span></a></li><li><a href=https://blog.lvcshu.com/about/ title=关于我><span>关于我</span></a></li><li><a href=https://blog.lvcshu.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">用于 gnet 的 Protocol buffers 编解码器</h1><div class=post-meta><span title='2021-09-17 18:30:00 +0800 CST'>2021-09-17 18:30:00</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;692 words&nbsp;·&nbsp;johnpoint</div></header><div class=post-content><p>要写一个 TCP 服务端，实现处理在纯 TCP 流中传输的 Protocol buffers 数据。网络框架很早就选好了，用性能杰出的 <a href=https://gnet.host/>gnet</a>，问题是 gnet 的示例库里面没有直接解析纯 Protocol buffers 的编解码器，于是乎只能自己动手了&mldr;</p><h2 id=协议分析>协议分析<a hidden class=anchor aria-hidden=true href=#协议分析>#</a></h2><p>从 TCP 流里面传过来的是经过简单处理的 Protocol buffers 数据，他在数据的头携带了这个数据包的长度信息，像是这样</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ][ 头 ][ 数据 ]
</span></span></code></pre></div><p>调用 golang 的 proto 官方库中的 <code>func DecodeVarint(b []byte) (uint64, int)</code> 方法可以从数据中拿到两个值，分别是 数据的完整长度、标明数据长度的头信息的长度。</p><p>由于没有特定的协议在包与包之间进行明显的划分，所以得用他的头数据来进行分包。</p><h2 id=解码器>解码器<a hidden class=anchor aria-hidden=true href=#解码器>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 储存连接内的相关信息</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>DataStruct</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fullLength</span>   <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>lenNumLength</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>fullData</span>     <span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>Codec</span><span class=p>)</span> <span class=nf>Decode</span><span class=p>(</span><span class=nx>c</span> <span class=nx>gnet</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Context</span><span class=p>().(</span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 从上下文里面拿出这个连接的编解码器储存 struct</span>
</span></span><span class=line><span class=cl>	<span class=nx>r</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Value</span><span class=p>(</span><span class=s>&#34;codec&#34;</span><span class=p>).(</span><span class=nx>DataStruct</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 读取缓冲区内的所有信息</span>
</span></span><span class=line><span class=cl>	<span class=nx>bytes</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Read</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 判断是否已经开始读取包</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 调用函数获取头中带的信息</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=nx>fullLength</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>		<span class=nx>fullLength</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>=</span> <span class=nx>proto</span><span class=p>.</span><span class=nf>DecodeVarint</span><span class=p>(</span><span class=nx>bytes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=p>=</span> <span class=nb>int</span><span class=p>(</span><span class=nx>fullLength</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 拿到当前时间已经被储存进 struct 的数据的长度</span>
</span></span><span class=line><span class=cl>	<span class=nx>fullDataLong</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 把读到的数据一把梭全部拼进 fullData</span>
</span></span><span class=line><span class=cl>	<span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>,</span> <span class=nx>bytes</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 判断长度是否符合要求</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span><span class=o>+</span><span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nf>ShiftN</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=o>+</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=o>-</span> <span class=nx>fullDataLong</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 截取有效的数据</span>
</span></span><span class=line><span class=cl>		<span class=nx>res</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>[</span><span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>:</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span><span class=o>+</span><span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 连接的缓存清空</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>		<span class=nx>ctx</span> <span class=p>=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;codec&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nf>SetContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>res</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 移动读取指针</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>ShiftN</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>bytes</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span> <span class=p>=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;codec&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>SetContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>上面那种解码方式是目前看运行状况来说暂时没有出现问题的方法，下面那一种则比较节省内存，两种解码方式区别主要是在于调用的 Read 函数不同，前者是把 gnet 的 ring buffer 里面的内容全部读取出来，而后者是先把头读取出来，拿到了完整的数据长度信息之后调用 ReadN 函数直接准确的将包体取出。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>Codec</span><span class=p>)</span> <span class=nf>Decode</span><span class=p>(</span><span class=nx>c</span> <span class=nx>gnet</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Context</span><span class=p>().(</span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 从上下文里面拿出这个连接的编解码器储存 struct</span>
</span></span><span class=line><span class=cl>	<span class=nx>r</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Value</span><span class=p>(</span><span class=s>&#34;codec&#34;</span><span class=p>).(</span><span class=nx>DataStruct</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>_</span><span class=p>,</span> <span class=nx>bytes</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>ReadN</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=nx>fullLength</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>		<span class=nx>fullLength</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>=</span> <span class=nx>proto</span><span class=p>.</span><span class=nf>DecodeVarint</span><span class=p>(</span><span class=nx>bytes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=p>=</span> <span class=nb>int</span><span class=p>(</span><span class=nx>fullLength</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=nx>fullDataLong</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>n</span><span class=p>,</span> <span class=nx>bytes</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>ReadN</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=o>+</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=o>-</span> <span class=nx>fullDataLong</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>,</span> <span class=nx>bytes</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>ShiftN</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span><span class=o>+</span><span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>res</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>[</span><span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>:]</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>		<span class=nx>ctx</span> <span class=p>=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;codec&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nf>SetContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>res</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span> <span class=p>=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;codec&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>SetContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在代码中也可以看见，头数据中的包体长度信息我是存在连接的上下文中的，所以在 gnet 触发连接打开的事件时需要将储存信息的 struct 塞进上下文中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>es</span> <span class=o>*</span><span class=nx>EventServer</span><span class=p>)</span> <span class=nf>OnOpened</span><span class=p>(</span><span class=nx>c</span> <span class=nx>gnet</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>(</span><span class=nx>out</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>action</span> <span class=nx>gnet</span><span class=p>.</span><span class=nx>Action</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=s>&#34;codec&#34;</span><span class=p>,</span> <span class=nx>DataStruct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>SetContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=编码器>编码器<a hidden class=anchor aria-hidden=true href=#编码器>#</a></h2><p>编码器这个部分就非常简单了，直接调用 proto 库里面的 EncodeVarint 函数就可以生成这个包体的头，将头信息放在包体的前面就可以将这个数据发送到客户端了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>Codec</span><span class=p>)</span> <span class=nf>Encode</span><span class=p>(</span><span class=nx>c</span> <span class=nx>gnet</span><span class=p>.</span><span class=nx>Conn</span><span class=p>,</span> <span class=nx>buf</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>buf</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>proto</span><span class=p>.</span><span class=nf>EncodeVarint</span><span class=p>(</span><span class=nb>uint64</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>buf</span><span class=p>))),</span> <span class=nx>buf</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>buf</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=2021-11-09-更新>2021-11-09 更新<a hidden class=anchor aria-hidden=true href=#2021-11-09-更新>#</a></h2><p>大意了，之前用上下文存储中间信息的方法有 <strong>严重的性能问题</strong>，在调用 golang 原生的 <code>context.WithValue</code> 方法时候，会在传入的上下文下面创建一个子上下文，这就导致了在一次又一次解码中，上下文树越来越庞大，而且每一层上下文内部都存储了本次解码的 <code>DataStruct</code>，造成内存泄漏的问题。</p><p>在苦苦查了好几天，并且修了几个有可能的内存泄漏隐患之后我才意识到这一点(秃头.jpg)</p><p>然后再看了下 <code>gnet.Conn</code> 的一个实现的 <code>Context()</code> 方法，发现他只是将我们传进去的东西存在了一个 map 里面，并不需要使用 <code>context</code> 相关的，所以简单的解决方法就是直接将 <code>DataStruct</code> 传进去，目前来看是解决了内存泄漏的问题，代码如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>Codec</span><span class=p>)</span> <span class=nf>Decode</span><span class=p>(</span><span class=nx>c</span> <span class=nx>gnet</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 从上下文里面拿出这个连接的编解码器储存 struct</span>
</span></span><span class=line><span class=cl>	<span class=nx>r</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Context</span><span class=p>().(</span><span class=nx>DataStruct</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>_</span><span class=p>,</span> <span class=nx>bytes</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>ReadN</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=nx>fullLength</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>		<span class=nx>fullLength</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>=</span> <span class=nx>proto</span><span class=p>.</span><span class=nf>DecodeVarint</span><span class=p>(</span><span class=nx>bytes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=p>=</span> <span class=nb>int</span><span class=p>(</span><span class=nx>fullLength</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=nx>fullDataLong</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>n</span><span class=p>,</span> <span class=nx>bytes</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>ReadN</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=o>+</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=o>-</span> <span class=nx>fullDataLong</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>,</span> <span class=nx>bytes</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>ShiftN</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span><span class=o>+</span><span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>res</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>[</span><span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>:]</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nf>SetContext</span><span class=p>(</span><span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>res</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span> <span class=p>=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;codec&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>SetContext</span><span class=p>(</span><span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>es</span> <span class=o>*</span><span class=nx>EventServer</span><span class=p>)</span> <span class=nf>OnOpened</span><span class=p>(</span><span class=nx>c</span> <span class=nx>gnet</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>(</span><span class=nx>out</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>action</span> <span class=nx>gnet</span><span class=p>.</span><span class=nx>Action</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>r</span> <span class=p>=</span> <span class=nx>DataStruct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>SetContext</span><span class=p>(</span><span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=2021-12-24-更新>2021-12-24 更新<a hidden class=anchor aria-hidden=true href=#2021-12-24-更新>#</a></h2><p>最近 gnet 发布了 v1.6.x 新版本，新版本的 编解码器行为有所改变，所以需要改造一下代码</p><p>主要的改动是在 gnet 库的 <a href=https://github.com/panjf2000/gnet/blob/d6cbe31e65ad3666acf8b4b9d4f55da9ec8c2fdd/eventloop_unix.go>eventloop_unix.go</a> 文件的 <a href=https://github.com/panjf2000/gnet/commit/302b2e55a1e0b62544983c0ea3d692fdaa5db4df#diff-b945f3b34ac34d1976944bc0c89304f8105c20362e3f915383250a3e0296f5c7R125>d1ca7f3</a> commit 中将进入 React 的时间点从返回的 packet 不为 nil 改为了返回的 err 不为 nil，所以在升级后需要做对应的修改</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=nx>ContinueRead</span> <span class=p>=</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;continue read&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>Codec</span><span class=p>)</span> <span class=nf>Decode</span><span class=p>(</span><span class=nx>c</span> <span class=nx>gnet</span><span class=p>.</span><span class=nx>Conn</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 从上下文里面拿出这个连接的编解码器储存 struct</span>
</span></span><span class=line><span class=cl>	<span class=nx>r</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Context</span><span class=p>().(</span><span class=nx>DataStruct</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>_</span><span class=p>,</span> <span class=nx>bytes</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>ReadN</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=nx>fullLength</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>		<span class=nx>fullLength</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>=</span> <span class=nx>proto</span><span class=p>.</span><span class=nf>DecodeVarint</span><span class=p>(</span><span class=nx>bytes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=p>=</span> <span class=nb>int</span><span class=p>(</span><span class=nx>fullLength</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>ContinueRead</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=nx>fullDataLong</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>n</span><span class=p>,</span> <span class=nx>bytes</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>ReadN</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span> <span class=o>+</span> <span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=o>-</span> <span class=nx>fullDataLong</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>,</span> <span class=nx>bytes</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>ShiftN</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullLength</span><span class=o>+</span><span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>res</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span><span class=p>[</span><span class=nx>r</span><span class=p>.</span><span class=nx>lenNumLength</span> <span class=p>:]</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span><span class=p>.</span><span class=nx>fullData</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nf>SetContext</span><span class=p>(</span><span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>res</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span> <span class=p>=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;codec&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>SetContext</span><span class=p>(</span><span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>ContinueRead</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2><ul><li><a href=https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/#614-%E4%BC%A0%E5%80%BC%E6%96%B9%E6%B3%95>Go 语言设计与实现 > 上下文 Context > 传值方法</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.lvcshu.com/tags/gnet/>Gnet</a></li><li><a href=https://blog.lvcshu.com/tags/tcp/>Tcp</a></li><li><a href=https://blog.lvcshu.com/tags/protocol-buffers/>Protocol Buffers</a></li><li><a href=https://blog.lvcshu.com/tags/codec/>Codec</a></li><li><a href=https://blog.lvcshu.com/tags/%E7%AC%94%E8%AE%B0/>笔记</a></li></ul><nav class=paginav><a class=prev href=https://blog.lvcshu.com/2021/11/24/zerotier-%E6%9E%84%E5%BB%BA%E5%86%85%E7%BD%91/><span class=title>« Prev</span><br><span>使用 Zerotier 异地组内网</span>
</a><a class=next href=https://blog.lvcshu.com/2021/07/28/%E8%A7%A3%E5%86%B3%E5%85%A8%E5%B1%8F%E8%83%8C%E6%99%AF%E5%9B%BE%E5%8D%A1%E9%A1%BF/><span class=title>Next »</span><br><span>解决全屏背景图卡顿</span></a></nav><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://johnpoints-blog-hexo.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.lvcshu.com/>johnpoint's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script async src=https://umami.uipo.cc/script.js data-website-id=7319ce07-a672-4d99-bf07-9ebb227d449d></script></body></html>